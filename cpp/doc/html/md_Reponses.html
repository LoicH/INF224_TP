<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Media server: Question 4 :</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Media server
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Question 4 : </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Comme pour la fonction d'affichage, la fonction pour jouer l'objet ne modifie pas l'objet et elle doit être déclarée dans les classes <a class="el" href="classPhoto.html">Photo</a> et <a class="el" href="classVideo.html">Video</a> et dans la classe de base afin de permettre un appel polymorphique sur la hiérarchie de classes. Cependant, contrairement à la fonction d'affichage, elle ne peut pas avoir d'implementation au niveau de la classe de base (car a priori chaque type d'objet nécessite un utilitaire différent pour être joué). Comment appelle-t'on ce type de méthode et comment faut-il les déclarer ?</b></p>
<p>Ce type de fonction est appelé "virtuelle pure". On la définit comme ceci : <code>virtual typeRenvoyé nomDeLaFonction(arguments) = 0;</code> pour ensuite l'implémenter dans les bonnes classes.</p>
<p><b>Si vous avez fait correctement ce qui précède, il ne sera plus possible d'instancer des objets de la classe de base. Pourquoi ?</b></p>
<p>Une classe qui déclare une fonction virtuelle pure est une classe abstraite, non instanciable.</p>
<h2>Question 5 :</h2>
<p>**On veut maintenant pouvoir traiter génériquement une liste comprenant à la fois des photos et des vidéos. Pour ce faire créer dans main.cpp un tableau dont les éléments sont tantôt une photo tantôt une vidéo. Ecrire ensuite une boucle permettant d'afficher les attributs de tous les élements du tableau (ou de les "jouer"). Cette boucle n'a pas besoin de connaître le type des élements : elle doit pouvoir traiter de la même manière tous les objets dérivant de la classe de base. **</p>
<p><b>Quelle est la propriété caractéristique de l'orienté objet qui permet de faire cela ?</b></p>
<p>Grâce aux fonctions virtuelles pures et aux classes abstraites, on peut appeler des méthodes sur des objets qui sont de types différents, mais qui ont une classe mère en commun : c'est le polymorphisme.</p>
<p><b>Qu'est-il spécifiquement nécessaire de faire dans le cas du C++ ? Quel est le type des éléments du tableau : est-ce que ce tableau contient les objets ou des pointeurs vers ces objets ? Pourquoi ? Comparer à Java.</b></p>
<p>Il faut allouer un tableau de pointeurs vers des objets <code><a class="el" href="classMedia.html">Media</a></code> : <code><a class="el" href="classMedia.html">Media</a> * mediaList[LIST_LENGTH];</code></p>
<p>Le tableau contient des pointeurs vers les objets, car comme on ne connaît pas la taille en mémoire des objets, ou si elle est variable, il vaut mieux considérer une case en mémoire comme un pointeur qui pointe vers l'objet voulu.</p>
<p>En Java ce comportement est assez opaque, le développeur n'a pas à se soucier de pointeurs/références, il alloue un tableau d'objets : <code>String[] myStringArray = new String[]{"abra", "ca", "dabra"};</code></p>
<h2>Question 6 :</h2>
<p><b>Que faut-il faire pour que l'objet <a class="el" href="classFilm.html">Film</a> ait plein contrôle sur ses données et que son tableau de durées des chapitres ne puisse pas être modifié (ou pire, détruit) à son insu ? (c'est l'objet qui doit pouvoir modifier ce qui lui appartient, pas les autres !)</b></p>
<p>On peut recopier le tableau des durées en mémoire à un autre endroit, pour que l'objet ait son propre tableau, sans que personne ne puisse le modifier.</p>
<p><b>Attention, le même problème se pose si un accesseur retourne directement ce tableau sans prendre les précautions nécessaires : la encore le contenu du tableau n'est pas récopié et l'appelant peut le modifier à sa guise. Quelle est la solution très simple que propose C/C++ pour éviter ce problème ?</b> Pour renvoyer un tableau et une longueur on peut faire quelque chose comme </p><pre class="fragment">size_t getChapters(unsigned int * destination){
        //on recopie le tableau des durées dans destination
        ...
        return f_length; 
    }
</pre><h2>Question 7 :</h2>
<p><b>Contrairement à Java ou C#, C/C++ ne gère pas la mémoire dynamique automatiquement (*) : comme il n'y a pas de ramasse miettes, tout ce qui a été créé avec new doit être détruit avec delete sinon on aura des fuites mémoires. Parmi les classes précédemment écrites quelles sont celles qu'il faut modifier afin qu'il n'y ait pas de fuite mémoire quand on détruit leurs instances ?</b></p>
<p>On utilise <code>new</code> seulement pour créer le tableau de durées de chapitres : </p><pre class="fragment">film.h:21: f_chapters = new unsigned int[length];
</pre><p>Donc il faut rajouter <code>delete[] f_chapters;</code> à <code>~Film()</code>.</p>
<p><b>De même, la copie d'objets peut poser problème dans certains cas. Pourquoi et que faudrait-il faire ?</b></p>
<h2>Question 8 :</h2>
<p><b>On rappelle aussi que la liste d'objets doit en fait être une liste de pointeurs d'objets. Pourquoi ? Comparer à Java.</b></p>
<p>Comme une liste est en fait une région de la mémoire, avec des cases contiguës, il est plus pratique de stocker les pointeurs vers les objets (les pointeurs sont de taille fixe donc occupent une place fixe en mémoire) plutôt que de stocker les objets directement.</p>
<p>En Java ce mécanisme est opaque et le développeur n'a pas à se poser la question : </p><pre class="fragment">String hi[] = {"hello","world","!"};
</pre><h2>Question 10 :</h2>
<p><b>Les méthodes précédentes permettent d'assurer la cohérence de la base de données car quand on crée un objet on l'ajoute à la table adéquate. Par contre, ce ne sera pas le cas si on crée un objet directement avec new (il n'appartiendra à aucune table). Comment peut-on l'interdire, afin que seule la classe servant à manipuler les objets puisse en créer de nouveaux ?</b></p>
<p>Il faut déclarer les constructeurs de <a class="el" href="classPhoto.html">Photo</a>, <a class="el" href="classVideo.html">Video</a>, <a class="el" href="classFilm.html">Film</a> avec friend. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
